{
    "about": "About",
    "project_info": "Project info",
    "week": "week",
    "weeks": "weeks",
    "day": "day",
    "days": "days",
    "towerDefense_subtitle": "Use of acquired skills, part 1",
    "towerDefense_about": "This project involved applying the skills acquired during previous projects by developing a tower defense game. The game had to include two types of enemies, two types of items to assist the player, and a controllable character.",
    "towerDefense_p1": "In this project, I had to use everything we learned during previous projects and reuse them in this one. The expected game was a tower defense. It had to include two types of enemies, two types of placeable items to help the player, and a controllable character.",
    "towerDefense_p2": "In this project, I was inspired by mobile tower defense games. The game is 2D with a single path that enemies take to reach the other side of the map. By clicking on the path, the controllable character moves there and automatically attacks enemies when they enter its zone.<br> The two types of towers are placeable at predefined locations. They are both different with different damage. It is also possible to sell the towers or upgrade them to a second level.<br> The wave system is simple with 5 waves with an increasing number of enemies. There are two types of enemies with different health points. The player loses one life point for each enemy that reaches the end of the path. When the player has zero life points, the game ends.",
    "towerDefense_figcaption_1": "The game with a wave timer, player health points, and money",
    "towerDefense_figcaption_2": "Upgrade or sell the tower",
    "zeldaLikeUnity_subtitle": "Use of acquired skills, part 2",
    "zeldaLikeUnity_about": "This project synthesizes the skills acquired during previous projects by developing a 'Zelda-like' game including an enemy, a puzzle, and a two-phase boss.",
    "zeldaLikeUnity_p1": "In this project, we had to use everything we learned during previous projects and reuse them in this one. The expected game type was a Zelda-like, so it had to include an enemy, a puzzle, and a boss with at least two phases.",
    "zeldaLikeUnity_p2": "I was inspired by the dungeons of 2D Zelda games (Link's Awakening). My game is 2D with a puzzle to retrieve the key that opens the boss door. The player has three life points, and when their life points reach zero, the game ends. If the player kills the boss, the game is won.<br> For the player animator, there are two blend trees: one for walking and one for attacks. For the character's attacks, I included a polygon collider so that the hitbox fits the attack animation.<br> When the player wants to change rooms, they enter the trigger box just before the exit. Then the script moves the player and the camera to center on the next room.",
    "zeldaLikeUnity_p3": "The enemies are limited; they can only follow the player, and when the player enters the enemy's hitbox zone, they lose one life point and get pushed back. But if the player attacks the enemy, the enemy loses one life point and gets pushed back. The enemy has three life points, and when it reaches zero life points, it disappears.<br> When the player enters the key's hitbox, they retrieve the key, which disappears from the room and appears on the player's UI. The player with the key can approach the boss door trigger box and press the 'E' key to open it, allowing the player to face the boss.",
    "zeldaLikeUnity_p4": "At the character's entrance, the boss starts attacking. The attacks are fireballs targeting the character. When the boss reaches half of its health, it enters its second phase, its color turns red, and its firing rate doubles. When the boss has no health left, it disappears, and the game is over.",
    "zeldaLikeUnity_figcaption_1": "Player animator",
    "zeldaLikeUnity_figcaption_2": "Attack polygon collider",
    "zeldaLikeUnity_figcaption_3": "Box collider to change rooms",
    "zeldaLikeUnity_figcaption_4": "Enemy and its hitbox",
    "zeldaLikeUnity_figcaption_5": "Key display on the UI",
    "zeldaLikeUnity_figcaption_6": "Boss door box collider",
    "zeldaLikeUnity_figcaption_7": "The boss with a fired fireball",
    "zeldaLikeUnity_figcaption_8": "Boss second phase",
    "rpgCplusplus_subtitle": "C++ Project, part 1",
    "rpgCplusplus_about": "This first C++ project involves creating a text-based RPG to focus on learning syntax and code structuring. The game features a hero moving in a 2D world, collecting treasures, weapons, and fighting enemies.",
    "rpgCplusplus_p1": "This project is the first in C++, with the goal of creating a text-based game in C++. The choice of text mode simplifies the input/output part to focus more on learning the language syntax and code structuring. The expected game is an RPG with a hero moving in a 2D world, collecting treasures, weapons, equipment, and fighting enemies.",
    "rpgCplusplus_p2": "The display is made to know where the character can go, what is in the current room, and the character's stats (health, damage, armor, money). Since the game is in console mode, all inputs are keyboard keys to press. To know all available keys, there is help at the beginning of the game and can be called throughout the game. (If the character wants to move from a room, they must press the key corresponding to a cardinal point (N, S, E, W)).<br> The generation of rooms, treasures, weapons, equipment, and enemies is hardcoded. I added a condition for enemy encounters, for example, you need a bow to fight a bat. When pressing the attack key to fight an enemy, there is a one in three chance that the character takes damage instead of the enemy. When the enemy dies, it drops money added to the character's purse.",
    "rpgCplusplus_p3": "Some rooms contain weapons or armor. Once collected, weapons will permanently improve the attack, and armor will permanently improve the defense. I implemented inheritance on weapons and armor, with the parent class being 'Equipment'. It is also possible to find treasures containing gold coins. They can be collected and added to the purse.<br> As a bonus, I added potions; there are two types: healing and defense. The console will show the amount of health or defense the potion gives. The healing potion adds health points even if the character is at maximum health. The defense potion adds defense, but it is temporary. The defense received will absorb the damage an enemy does, but it disappears after that.",
    "rpgCplusplus_figcaption_1": "Condition to fight the bat",
    "rpgCplusplus_figcaption_2": "Combat and money gain",
    "rpgCplusplus_figcaption_3": "Armor added to armor stat",
    "rpgCplusplus_figcaption_4": "Money added to the purse",
    "rpgCplusplus_figcaption_5": "Healing potion",
    "rpgCocos2d_subtitle": "C++ Project, part 2",
    "rpgCocos2d_about": "This project, a continuation of the C++ RPG project, aims to learn using the Cocos2d-x engine to deepen C++ concepts. As a group, we used the gameplay code to focus on the engine's usage and implementing graphics, sound, and user interactions.",
    "rpgCocos2d_p1": "This project is a continuation of the <a href=\"rpgCplusplus.html\" class=\"text-decoration-none\">C++ RPG<\/a> project, with the goal of learning to use a C++ engine and deepening C++ concepts. The engine used is Cocos2d-x, a relatively low-level engine oriented towards '2D mobile games'.<br> The gameplay code is taken from the previous project to focus on the engine's usage and implementing graphics (sprite), sound, and user interactions. This project being a group work, we had to keep only one code from the previous project. After discussion, my code was used in this project.",
    "rpgCocos2d_p2": "For the chosen topic, we had to display an overview of the rooms (map), display the character and treasures in the room, an interface showing the current room coordinates. We had to add interactions to change rooms or collect treasures and add sound effects to them.<br> I took care of adding sprites for the room, character, and map. On the map, the character moves in real-time when changing rooms. Since we reused my code, each door contains a pointer to a room. I made sure to display a door if there is a room at each coordinate. The engine allows giving a collision box to the sprites. I used that to know if the player clicked on a door sprite and display the next room.<br> I added treasure sprites and adapted the functions I made to have visual feedback when collecting a treasure. I added all the sound effects (door, treasure, player/enemy damage) with a bonus ambient music. As a bonus, we added enemy presence and simple combat with them.",
    "rpgCocos2d_figcaption_1": "Collecting a treasure",
    "rpgCocos2d_figcaption_2": "Combat with an enemy",
    "platformerUnreal_subtitle": "Platformer with arenas",
    "platformerUnreal_about": "The project involves developing, as a team of three, a platformer game with a cartoon aesthetic. The game includes enemies, sound effects, and a UI. Each team member designed an arena, for a total of three arenas.",
    "platformerUnreal_p1": "This project is the first using Unreal Engine 4 with blueprints. The goal is to create a platformer level as a team of three. The graphic style is cartoon. The game must include AIs, sounds, UI, and animations. Each member must create at least one arena for a total of three arenas.",
    "platformerUnreal_p2": "In this project, I made my arena, the path to access it, the main menu, and added some sounds. My arena consists of platforms falling at a fixed rhythm. On these platforms, enemies appear. The enemies have simple logic; they follow the player, but to kill them, you have to jump on their heads. To complete my arena, the player must kill all enemies without falling or dying; otherwise, the arena resets.",
    "platformerUnreal_figcaption_1": "Main menu",
    "platformerUnreal_figcaption_2": "Path to the arena",
    "platformerUnreal_figcaption_3": "The arena",
    "platformerUnreal_figcaption_4": "The arena in-game",
    "diorama_subtitle": "Shader and particles",
    "diorama_about": "This diorama aims to introduce the basics of shaders and particles by creating a scene with a magic portal, two animated characters triggering effects when crossing the portal. The project also includes the use of lights, particles, and a shader for specific effects",
    "diorama_p1": "This project aims to teach us the basics of art. To do this, we had to create a scene containing at least one magic portal, two animated characters (when a character crosses the portal, an effect is triggered). Play with lights and particles as well as a shader that produces a specific effect. We had to use a texture we created beforehand.",
    "diorama_p2": "We started by learning the basics of shaders first on Unity (HLSL and Shader Graph) then on Unreal Engine. For textures, we used Substance Painter and Substance Designer. For particles, we used the Niagara particle system from Unreal Engine.<br> My goal was to create a mystical forest, so I created firefly-shaped particles to create a fantasy forest atmosphere. I used fbx trees and a portal that I implemented in the scene. I added particles to the portal and an action when a character enters it. There are two types of trees; those on the outside, I made their textures with Substance Designer. Added mushrooms with an emissive texture and a light for the mystical side. As well as adding volumetric light.<br> The characters follow a predefined path. One of the two characters goes directly to the portal. When it reaches its destination, a particle plays, and it teleports to its initial location.",
    "diorama_figcaption_1": "Tree texture",
    "diorama_figcaption_2": "Firefly particle",
    "diorama_figcaption_3": "Portal particle",
    "diorama_figcaption_4": "Teleportation particle",
    "breakout_subtitle": "C++ Project with SFML",
    "breakout_about": "This project aims to familiarize us with the SFML API by developing, in pairs, a brick-breaker game where a cannon replaces the usual paddle.",
    "breakout_p1": "This project aims to teach us the use of the SFML API. It allows the display of images, geometric shapes, and user event handling. With the SFML API, in a group of two, we had to create a brick-breaker game, but instead of a paddle, we use a cannon that can shoot a ball in all directions.",
    "breakout_p2": "When the player clicks the left mouse button, we get the mouse position on the window. Then we calculate the difference between the ball position (in the cannon) and the mouse position, normalize the resulting vector, and give it to the ball with a velocity; the ball moves in the desired direction.<br> When the ball hits a brick with a number on it, the ball bounces, and the number on the brick decreases. When the number on the brick reaches 0, the ball bounces, and the brick disappears. Silver bricks are unbreakable, and the ball bounces on contact. When the ball exits the bottom of the window, it is destroyed, and a new ball is created in the cannon. In this project, I handled the collision part with the ball, bricks, and window borders.<br> The collisions of the ball and bricks are done by an SFML function that retrieves the sprite borders. When a collision is detected, whether when the ball hits a window border or a brick, the ball direction vector is inverted along the touched axis.",
    "stealthUE_subtitle": "Metal Gear?",
    "stealthUE_about": "We used Unreal Engine 4 and C++ to create a stealth game with enemies tracking the player. The player must collect food and bring it to their hideout while avoiding enemies.",
    "stealthUE_p1": "This project aims to use Unreal Engine 4 with C++ but also with the features offered by the engine. The goal is to create a stealth game level developed in a team of three. The game must include AIs chasing the player if detected, or else the player must deliver food to different spots in the level. A UI to know the player's progress. And a playable character that can take food and bring it to their hideout.<br> The gameplay loop is the player starts in their hideout and must bring food one by one delivered in the room by enemies, avoiding them. If the player contacts an enemy, they lose. If the player brings 5 foods to their hideout, they win.",
    "stealthUE_p2": "In this project, I handled all the UI. I started with the player's interface, which is a progress bar with a food image to show the player's progress. Then I made the victory and defeat screens. The buttons are developed in C++.",
    "stealthUE_p3": "After that, I made the main menu, which is a new real-time scene, as well as the pause menu. While making the main menu, I took the opportunity to do the level design of the level. I added a system that allows the player to change the bindings of their commands at any time.<br> This project allowed me to learn a lot about UI and code related to widgets. Learning how to change command bindings in real-time was very instructive.",
    "stealthUE_figcaption_1": "Player UI",
    "stealthUE_figcaption_2": "Victory screen",
    "stealthUE_figcaption_3": "Defeat screen",
    "stealthUE_figcaption_4": "Main menu",
    "stealthUE_figcaption_5": "Pause menu",
    "stealthUE_figcaption_6": "Keybinding screen",
    "goblinInvasionUnity_subtitle": "Twitch plays with SOLID principles",
    "goblinInvasionUnity_about": "We developed a Twitch-linked game following SOLID principles, where chat commands allow players to collaborate to defend a castle against waves of monsters.",
    "goblinInvasionUnity_p1": "The principle of the game was to create a game playable on Twitch with commands linked to the chat while using SOLID principles.<br> What is the SOLID principle? The SOLID principle proposes five principles (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) aimed at creating modular, scalable, and maintainable systems by promoting code clarity, flexibility, and reusability. These principles encourage robust and extensible object-oriented design.",
    "goblinInvasionUnity_p2": "The goal of the game is to collaborate to protect the castle from waves of monsters. Three categories of threatening creatures are to be faced: zeppelins, ballistae, and goblins.<br> The development of this game involved a team of three people, each with specific responsibilities. One person handled the integration between the Twitch API and the game, another focused on artistic design, the user interface (UI), and the essence of gameplay. I led the development of the player character and handled some of the enemies.",
    "goblinInvasionUnity_p3": "Players spawn randomly at predefined points, displaying their username above their head, retrieved via the Twitch API. The player's attack was implemented using the command pattern. Most data, such as the damage dealt by an arrow or the different cooldown times, are stored in scriptable objects. Saving is done within a coroutine and a task that is then stored in a file in the game folder.",
    "goblinInvasionUnity_figcaption_1": "Available commands",
    "goblinInvasionUnity_figcaption_2": "Connection interface",
    "tankAIUnity_subtitle": "AI: movement and behaviour",
    "tankAIUnity_about": "Starting from Unity's Tanks! project, we implemented AI using a behaviour tree and path algorithms (A*, Dijkstra, NavMesh). Two 'King of the Hill' game modes were created: AI vs AI and Player vs AI.",
    "tankAIUnity_p1": "In this project, we used Unity's Tanks! project, which we adapted to introduce the requested features, such as hot-swapping the tank's movement method from the editor (A*, Dijkstra, and NavMesh). Two game modes were developed for this project: AI vs AI and Player vs AI. Additionally, three AI behaviours were developed: alpha, mainly focused on scoring, beta, which patrols or scores if the area is not already captured, and omega, which patrols or defends the alpha if attacked.<br> Victory is achieved by the number of points. A team must reach a certain number of points to win, or we check which team has the most points after a certain time. To score points, the central area must be controlled, like in a 'King of the Hill'. To control the area, at least one tank must be physically present in it for a certain time. Once the area is controlled by a team, it earns points if there are tanks present in the area. The more tanks present, the more points earned.",
    "tankAIUnity_p2": "I developed the tank movement algorithms, including A* and Dijkstra, and implemented Unity's internal movement solution, the NavMesh. I also set up a hot-swap mechanism for choosing the tank's movement method, implemented obstacle avoidance using raycasts, allowing players to pilot a tank, and created a scoring system associated with the central base.",
    "tankAIUnity_p3": "The state machine was used for the capture zone, while the behaviour tree was used to model the various AI behaviours. These two systems are managed using scriptable objects. The AIs interact with each other, sharing information such as knowing enemies pursuing the team's alpha and enemies present in the capture zone.",
    "tankAIUnity_figcaption_1": "AI vs AI",
    "tankAIUnity_figcaption_2": "AI vs AI vs Player",
    "tankAIUnity_figcaption_3": "Different colour coding for AIs",
    "snowSicknessUnity_subtitle": "Snowball fight with Netcode",
    "snowSicknessUnity_about": "Our team of five developed a multiplayer snowball fight game. This game was developed using Netcode for GameObjects technology.",
    "snowSicknessUnity_p1": "This project was to create a game with Netcode on the Christmas theme, developed by a team of five people. We chose a peer-to-peer multiplayer game where the objective is to participate in a snowball fight. Each player has three health points and a minimap to locate their position and their opponents. When a player wants to charge a snowball, they must stay still while charging. The game ends when there are no more opponents.",
    "snowSicknessUnity_p2": "I integrated Netcode for GameObjects to take advantage of its features simplifying multiplayer game development. This solution offers a flexible and extensible approach to network object synchronization, improving authority and prediction management. The use of Relay, a Netcode for GameObjects service, simplifies the connection between the client and the host.",
    "snowSicknessUnity_p3": "I set up the lobby with its essential components, including connection management, disconnection, client identification, nickname, lobby code, and skin selection. I implemented the synchronization of events such as player deaths using ServerRPC and ClientRPC. Similarly, the synchronization of data such as health, lobby code, or players is implemented using NetworkVariables and NetworkList. Unity components such as Animator, Transform, Rigidbody, etc., are coordinated with client authority using Netcode for GameObjects' native components.",
    "snowSicknessUnity_figcaption_1": "The lobby",
    "snowSicknessUnity_figcaption_2": "The end podium",
    "middleBlades_subtitle": "A hypercasual idle game",
    "middleBlades_about": "In a project, three hypercasual games are created in a team of five, each incorporating ads or in-app purchases. This one is an idle game where players automatically accumulate resources to improve their attack speed and damage.",
    "middleBlades_p1": "The goal of this project was to create three hypercasual games, with a team of five people dividing individual production. Each game had to incorporate ads and/or in-app purchases.<br> The game I developed, in collaboration with another person, is an idle game. An idle game is a genre where players progress by accumulating automatically generated resources, promoting a relaxed and continuous gaming experience even without active interaction. It is also possible to speed up progress and improve stats (attack speed, damage, time required to defeat the zone boss) by clicking to help or accelerate the process. We were inspired by the mobile game 'Tap Titans' to create this game.",
    "middleBlades_p2": "Having expertise in integrating and using ads, I handled the design, game interface, and part of the gameplay. I designed the environment where the hero evolves, managing the transition when the enemy is defeated. I also set up the hero upgrade system, created a boss to mark the end of a level and the transition to the next, while adding effects and particles to enhance its visual appeal. Ads were integrated via Unity's built-in service."
}

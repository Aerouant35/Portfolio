{
    "about": "A propos",
    "project_info": "Info projet",
    "week": "semaine",
    "weeks": "semaines",
    "day": "jour",
    "days": "jours",
    "towerDefense_subtitle": "Utilisation des notions acquises, partie 1",
    "towerDefense_about": "Ce projet consistait à appliquer les compétences acquises lors des précédents projets en développant un jeu de type tower defense. Le jeu devait inclure deux types d'ennemis, deux types d'objets pour aider le joueur, et un personnage contrôlable.",
    "towerDefense_p1": "Sur ce projet, je devais utiliser tout ce qu'on a appris au cours des précédents projets et les réutiliser dans celui-ci. Pour ce projet, le jeu attendu était un tower defense. Il devait comporter deux types d'ennemis et deux types d'objets plaçable pour aider le joueur et un personnage contrôlable.",
    "towerDefense_p2": "Sur ce projet, je me suis inspiré des tower defense mobile, le jeu est en 2D avec un chemin unique que les ennemis empruntent pour atteindre l'autre côté de la carte. En cliquant sur le chemin, le personnage contrôlable s'y déplacera et il attaque automatiquement les ennemis dès qu'il entre dans sa zone.<br> Les deux types de tours sont plaçable à des endroits prédéfinis. Elles sont toutes les deux différentes avec des dégâts différents. Il est également possible de vendre les tours ou de les améliorer à un second niveau.<br> Le système vague est simple avec 5 vagues avec un nombre croissant d'ennemis. Il y a deux types d'ennemi avec des points de vie différents. Le joueur perd un point de vie à chaque ennemi qui atteint la fin du chemin. Quand le joueur a zéro point de vie la partie se termine.",
    "towerDefense_figcaption_1": "Le jeu avec un timer pour les vagues, les points de vie et l'argent du joueur",
    "towerDefense_figcaption_2": "Amélioration ou vente de la tour",
    "zeldaLikeUnity_subtitle": "Utilisation des notions acquises, partie 2",
    "zeldaLikeUnity_about": "Ce projet synthétise les compétences acquises lors des précédents projets, en développant un jeu de type \"Zelda-like\" incluant un ennemi, une énigme, et un boss à deux phases.",
    "zeldaLikeUnity_p1": "Sur ce projet, on devait utiliser tout ce qu'on avait appris au cours des précédents projets et les réutiliser dans celui-ci. Pour ce projet, le type de jeu demandé est un zelda like donc il devait comporter un ennemi, une énigme et un boss avec au minimum deux phases.",
    "zeldaLikeUnity_p2": "Je me suis inspiré des donjons des zelda 2D (Link's Awakening). Mon jeu est en 2D avec pour énigme la récupération de la clé qui permet d'ouvrir la porte du boss. Le joueur a trois points de vie et quand ses points de vie atteignent zéro, c'est la fin de la partie. Si le joueur tue le boss, la partie est gagnée.<br> Pour l'animator du joueur, il y a deux blend tree : un pour quand il marche et un pour ses attaques. Pour les attaques du personages, j'ai inclus un polygon collider pour que la hitbox épouse l'animation de l'attaque.<br> Lorsque le joueur veut changer de salle, il entre en contact avec la trigger box qui se trouve juste avant la sortie de celle-ci. Alors le script fait faire un déplacement du joueur et de la caméra pour se recentrer sur la salle suivante.",
    "zeldaLikeUnity_p3": "Les ennemis sont limités, ils ne peuvent que suivre le joueur et quand celui-ci rentre dans la zone de la hitbox de l'ennemi, il perd un point de vie et se fait repousser. Mais si le joueur attaque l'ennemi, l'ennemi perd un point de vie et se fait repousser. L'ennemi a trois points de vie et quand il atteint zéro point de vie, il disparaît.<br> Quand le joueur entre la hitbox de la clé, le joueur récupère la clé, celle-ci disparaît de la salle et s'affiche sur l'UI du joueur. Le joueur qui a la clé et qui s'approche de la trigger box de la porte du boss et appuie sur la touche \"E\", celle-ci s'ouvre et permet au joueur d'affronter le boss.",
    "zeldaLikeUnity_p4": "A l'entrée du personnage, le boss commence à attaquer. Ses attaques sont des boules de feu qui ciblent le personnage. Quand le boss atteint la moitié de sa vie, il entre dans sa deuxième phase, sa couleur devient rouge et sa cadence de tire est augmentée du double. Quand le boss n'a plus de vie, il disparaît et la partie est finie.",
    "zeldaLikeUnity_figcaption_1": "Animator du joueur",
    "zeldaLikeUnity_figcaption_2": "Polygon collider de l'attaque",
    "zeldaLikeUnity_figcaption_3": "Box collider pour changer de salle",
    "zeldaLikeUnity_figcaption_4": "Ennemi et sa hitbox",
    "zeldaLikeUnity_figcaption_5": "Affiche de clé sur l'UI",
    "zeldaLikeUnity_figcaption_6": "Box collider de la porte",
    "zeldaLikeUnity_figcaption_7": "Le boss avec une boule de feu lancé",
    "zeldaLikeUnity_figcaption_8": "Deuxième phase du boss",
    "rpgCplusplus_subtitle": "Projet C++, partie 1",
    "rpgCplusplus_about": "Ce premier projet en C++ consiste à créer un RPG en mode texte pour se concentrer sur l'apprentissage de la syntaxe et la structuration du code. Le jeu comporte un héros se déplaçant dans un monde 2D, ramassant des trésors, des armes et combattant des ennemis.",
    "rpgCplusplus_p1": "Ce projet est le premier en C++, le but est de réaliser un jeu en mode texte en C++. Le choix du mode texte est pour simplifier la partie input/output pour plus se concentrer sur l'apprentissage de la syntaxe du langage, la structuration du code. Le jeu attendu est un RPG avec un héros qui se déplace dans un monde en 2D, ramasse des trésors, des armes, des équipements et combat des ennemis.",
    "rpgCplusplus_p2": "L'affichage est fait pour savoir où le personnage peut aller, ce qu'il y a dans la pièce actuelle et les statistiques du personnage (vie, dégâts, armure, argent). Comme le jeu est en console donc tous les inputs sont des touches du clavier qu'il suffit de presser. Pour connaître toutes les touches disponibles, il y a une aide au début du jeu et qui peut être appelée tout au long du jeu. (Si le personnage veut se déplacer d'une salle, il doit appuyer sur la touche correspondant à un point cardinal (N, S, E, W)).<br> La génération de salles, de trésor, d'arme, d'équipement, et d'ennemi est hardcodée. J'ai rajouté une condition pour l'affrontement des ennemis par exemple, il faut un arc pour affronter une chauve-souris. Lorsque qu'on appuie sur la touche d'attaque pour affronter un ennemi, il y a une chance sur trois que ce soit le personnage qui prend des dégâts et non l'ennemi. Quand l'ennemi meurt, il laisse tomber de l'argent qui est ajouté à la bourse du personnage.",
    "rpgCplusplus_p3": "Certaines salles contiennent des armes ou de l'armure. Une fois récupérée, les armes amélioreront l'attaque et l'armure améliorera la défense de façon permanente. J'ai mis en place de l'héritage sur les armes et les armures dont la classe mère est \"Equipment\". Il est également possible de trouver des trésors qui contiennent des pièces d'or. Elles peuvent être récupérées et s'ajouteront à la bourse.<br> En bonus, j'ai rajouté des potions, il en existe deux types : une de soin et une de défense. La console donnera le montant de point de vie ou de défense que la potion donnera. La potion de soin va ajouter des points de vie même si le personnage est au maximum de sa vie. La potion de défense va ajouter de la défense, mais elle est temporaire. La défense reçue permettra d'encaisser les dégâts que fait un ennemi, mais disparaîtra suite à ça.",
    "rpgCplusplus_figcaption_1": "Condition pour affronter la chauve-souris",
    "rpgCplusplus_figcaption_2": "Combat et gain d'argent",
    "rpgCplusplus_figcaption_3": "L'armure ajouté à la statistique d'armure",
    "rpgCplusplus_figcaption_4": "Argent ajouté à la bourse",
    "rpgCplusplus_figcaption_5": "Potion de soins",
    "rpgCocos2d_subtitle": "Projet C++, partie 2",
    "rpgCocos2d_about": "Ce projet, une suite du projet RPG en C++, vise à apprendre à utiliser le moteur Cocos2d-x pour approfondir les notions de C++. En groupe, nous avons repris le code du gameplay pour nous concentrer sur l'utilisation du moteur, ainsi que l'implémentation des graphismes, du son et des interactions utilisateur.",
    "rpgCocos2d_p1": "Ce projet une suite du projet <a href=\"rpgCplusplus.html\" class=\"text-decoration-none\">RPG C++<\/a>, avec comme objectif d'apprendre à utiliser un moteur C++ et d'approfondir les notions C++. Le moteur utilisé est Coco2d-x, un moteur est relativement bas-niveau, orienté \"jeux 2D pour mobiles\".<br> Le code du gameplay est repris du projet précédent pour se concentrer sur l'utilisation du moteur et l'implémentation de graphismes (sprite), du son et des interactions utilisateur. Ce projet étant un travail en groupe, on devait garder qu'un seul code du projet précédent. Après concertation, ce fut mon code qui a été utilisé dans ce projet.",
    "rpgCocos2d_p2": "Sur le sujet que nous avons choisi, on devait afficher une vue d'ensemble des salles (carte), afficher la présence du personnage et des trésors dans la salle, une interface qui affiche les coordonnées de la salle actuelle. Il fallait ajouter des interactions pour changer de salle ou ramasser des trésors et mettre des effets sonores sur celle-ci.<br> Je me suis occupé de l'ajout des sprites la salle, du personnage et de la carte. Sur la carte, le personnage se déplace en temps réel lors d'un changement de salle. Comme on a repris mon code donc chaque porte contient le pointeur d'une salle, j'ai fait en sorte d'afficher une porte s'il existe une salle à chaque coordonnée. Le moteur permet de donner une boite de collision aux sprites, je me suis servis de ça pour savoir si le joueur a cliqué sur un sprite d'une porte et d'afficher la salle suivante.<br> J'ai rajouté les sprites des trésors, j'ai utilisé et adaptés les fonctions que j'avais faites pour pouvoir avoir un retour visuel lors de la récupération d'un trésor. J'ai ajouté tous les effets sonores (porte, trésor, dégâts joueur/ennemi) avec en bonus une musique d'ambiance. En bonus, nous avons ajouté la présence d'ennemi et un combat simple avec eux.",
    "rpgCocos2d_figcaption_1": "Récupération d'un trésor",
    "rpgCocos2d_figcaption_2": "Combat avec un ennemi",
    "platformerUnreal_subtitle": "Plateformer avec des arènes",
    "platformerUnreal_about": "Le projet consiste à développer, en équipe de trois, un jeu de plateforme avec une esthétique cartoon. Le jeu inclus des ennemis, des effets sonores, ainsi qu'une UI. Chaque membre de l'équipe a conçu une arène, pour un total de trois arènes.",
    "platformerUnreal_p1": "Ce projet est le premier avec le moteur Unreal Engine 4 utilisés avec blueprint. Le but est de créer un niveau de jeu type plateformer en équipe de trois. La charte graphique est cartoon. Le jeu doit comporter des IA, des sons, un UI, des animations. Au moins chaque membre doit créer une arène pour un total de trois arènes.",
    "platformerUnreal_p2": "Sur ce projet, j'ai fait mon arène, le chemin pour y accéder, le menu principal et l'ajout de quelques sons. Mon arène est composée de plateforme qui tombe à un rythme fixe. Sur ces plateformes, il y a des ennemis qui apparaissent. Les ennemis ont une logique simple, ils suivent le joueur, mais pour les tués il faut leur sauter sur la tête. Pour venir à bout de mon arène, il faut que le joueur tue tous les ennemis sans tomber et sans mourir sinon l'arène se réinitialise.",
    "platformerUnreal_figcaption_1": "Le menu principal",
    "platformerUnreal_figcaption_2": "Chemin vers l'arène",
    "platformerUnreal_figcaption_3": "L'arène",
    "platformerUnreal_figcaption_4": "L'arène en jeu",
    "diorama_subtitle": "Shader et particules",
    "diorama_about": "Ce diorama vise à initier aux bases des shaders et particules en créant une scène avec un portail magique, deux personnages animés déclenchant des effets lorsqu'ils traversent le portail. Le projet inclut également l'utilisation de lumières, de particules et d'un shader pour des effets spécifiques",
    "diorama_p1": "Ce projet a pour but de nous apprendre à utiliser les bases d'art. Pour cela on devait créer une scène qui contient au moins un portail magique, deux personnages animés (quand un personnage traverse le portail un effet se déclenche). Jouer avec les lumières et les particules ainsi qu'un shader qui produit un effet spécifique. Il faut utiliser une texture qu'on aura créée au préalable.",
    "diorama_p2": "On a commencé par apprendre les bases des shaders d'abord sur Unity (HLSL et Shader Graph) puis sur Unreal Engine. Pour les textures on a utilisé les logiciels Substance Painter et Substance Designer. Pour les particules ont utilisé le système de particules Niagara d'Unreal Engine.<br> Mon but était de créer une forêt mystique pour cela j'ai créé des particules en forme de lucioles pour créer une atmosphère forêt fantaisiste. J'ai récupéré des fbx d'arbres et un de portail que j'ai implémenté dans la scène. J'ai ajouté des particules au portail et une action quand un personnage entre dedans. Il y a deux types d'arbres et ceux qui sont le plus à l'extérieur, j'ai faits leurs textures avec Substance Designer. Ajout de champignons avec une texture émissive et d'une lumière pour le côté mystique. Ainsi que l'ajout d'une lumière volumétrique.<br> Les personnages suivent un parcours prédéfini. Un des deux personnages va directement au portail, quand il atteint sa destination une particule se joue et il se téléporte à son emplacement initial.",
    "diorama_figcaption_1": "Texture de l'arbre",
    "diorama_figcaption_2": "Particule de lucioles",
    "diorama_figcaption_3": "Particule de portail",
    "diorama_figcaption_4": "Particule de téléportation",
    "breakout_subtitle": "Projet C++ avec SFML",
    "breakout_about": "Ce projet vise à nous familiariser avec l'API SFML en développant, en binôme, un jeu de casse-briques où un canon remplace la barre habituelle.",
    "breakout_p1": "Ce projet a pour but de nous apprendre l'utilisation de l'API SFML. Elle permet l'affichage d'images, de formes géométriques et la gestion des évènements utilisateurs. Avec l'API SFML, en groupe de deux, nous devions créer un jeu de casse brique, mais à la place de la barre, on utilise un canon qui permet de tirer une balle dans toutes les directions.",
    "breakout_p2": "Lorsque le joueur fait un clic sur le bouton gauche de la souris, on récupère la position de la souris sur la fenêtre. Ensuite on fait la différence en la position de la balle (qui est dans le canon) et la position de la souris, on normalise le vecteur qui en sort et on le donne à la balle avec une vélocité, la balle part dans la direction souhaitée.<br> Quand la balle touche une brique avec un chiffre dessus, la balle rebondie et le chiffre sur la brique décrémente. Quand le chiffre sur la brique passe à 0, la balle rebondie et la brique disparait dans un second temps. Les briques argent sont des briques incassables et la balle rebondie à son contact. Lorsque la balle sort du bas de la fenêtre, celle-ci est détruite et une nouvelle balle est créée dans le canon. Sur ce projet, je me suis occupé de la partie collision avec la balle, les briques et les bords de la fenêtre de l'application. <br> Les collisions de la balle et des briques sont faite par une fonction SFML qui permet de récupérer les bords du sprite. Lorsqu'une collision est détectée que ce soit lorsque la balle touche un bord de la fenêtre du jeu ou lorsqu'elle touche une brique, le vecteur de direction la balle est inversé selon l'axe touché.",
    "stealthUE_subtitle": "Metal Gear ?",
    "stealthUE_about": "Nous avons utilisé Unreal Engine 4 et du C++ pour créer un jeu d'infiltration avec des ennemis traquant le joueur. Le joueur doit collecter de la nourriture et l'apporter à sa cachette tout en évitant les ennemis.",
    "stealthUE_p1": "Ce projet a pour but d'utiliser le moteur Unreal Engine 4 avec le C++ mais aussi avec les fonctionnalités proposées par le moteur. Le but est de créer un niveau de jeu type infiltration développer en équipe de trois. Le jeu doit comporter des IA qui poursuive le joueur s'il est repéré ou sinon il doit déposer de la nourriture à différents endroits dans le niveau. Une UI pour connaitre la progression du joueur. Et un personnage jouable qui peut prendre de la nourriture et l'emmener à sa cachette.<br> La boucle de gameplay est le joueur qui commence dans sa cachette, il doit ramener un par un de la nourriture apporté dans la salle par les ennemis, qu’il doit éviter. Si le joueur entre en contact avec un ennemi, il perd. Si le joueur ramène 5 aliments dans sa cachette, il gagne.",
    "stealthUE_p2": "Sur ce projet, je me suis occupé de tout ce qui est UI. J'ai commencé par l'interface du joueur qui est une progress bar avec une image de la nourriture qu'il doit récupérer pour montrer la progression du joueur. Ensuite j'ai fait les écrans de victoire et de défaite. Les boutons sont développés en C++.",
    "stealthUE_p3": "Suite à ça, j'ai fait le menu principal, qui est une nouvelle scène en temps réel, ainsi que le menu pause. En faisant le menu principal, j'en ai profité pour faire le level design du niveau. J'ai ajouté un système qui permet au joueur de pouvoir changer le bindings de ses commandes à tous moments.<br> Ce projet m'a permis de beaucoup apprendre sur l'UI et au code lier au widget. Apprendre comment changer le bindings des commandes en temps réel fut très instructif.",
    "stealthUE_figcaption_1": "UI du joueur",
    "stealthUE_figcaption_2": "Écran de victoire",
    "stealthUE_figcaption_3": "Écran de défaite",
    "stealthUE_figcaption_4": "Menu principal",
    "stealthUE_figcaption_5": "Menu de pause",
    "stealthUE_figcaption_6": "L'écran du keybinding",
    "goblinInvasionUnity_subtitle": "Twitch plays avec les principes SOLID",
    "goblinInvasionUnity_about": "Nous avons développé un jeu lié à Twitch en suivant les principes SOLID, où les commandes de chat permettent aux joueurs de collaborer pour défendre un château contre des vagues de monstres.",
    "goblinInvasionUnity_p1": "Le principe du jeu étais de créer un jeu jouable sur Twitch avec des commandes liés au chat tout en utilisant le principe SOLID.<br> Qu'est-ce que le principe SOLID ? Le principe SOLID propose cinq principes (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) visant à créer des systèmes modulaires, évolutifs et faciles à maintenir en favorisant la clarté, la flexibilité et la réutilisabilité du code. Ces principes encouragent une conception orientée objet robuste et extensible.",
    "goblinInvasionUnity_p2": "L'objectif du jeu consiste à collaborer afin de protéger le château contre les vagues de monstres. Trois catégories de créatures menaçantes sont à affronter : les zeppelins, les balistes et les gobelins.<br> Le développement de ce jeu a impliqué une équipe de trois personnes, avec chacun ayant des responsabilités spécifiques. Une personne a pris en charge l'intégration entre l'API Twitch et le jeu, une autre s'est concentrée sur le design artistique, l'interface utilisateur (UI) et l'essence même du gameplay. De mon côté, j'ai dirigé le développement du personnage joueur et m'occupais également d'une partie des ennemis.",
    "goblinInvasionUnity_p3": "Les joueurs apparaissent de manière aléatoire sur des points prédéfinis, affichant leur pseudonyme au-dessus de leur tête, récupéré via l'API Twitch. L'attaque du joueur a été implémentée à l'aide du pattern command. La majorité des données, telles que les dégâts infligés par une flèche ou les différents temps de recharge, sont enregistrées dans des scriptables objects. La sauvegarde est réalisée au sein d'une coroutine et d'une tâche qui est ensuite stockée dans un fichier dans le dossier du jeu.",
    "goblinInvasionUnity_figcaption_1": "Les commandes disponibles",
    "goblinInvasionUnity_figcaption_2": "Interface de connexion",
    "tankAIUnity_subtitle": "IA : déplacement et comportement",
    "tankAIUnity_about": "En partant du projet Tanks! d'Unity, nous avons implémenté une IA utilisant un behaviour tree et des algorithmes de chemin (A*, Dijkstra, NavMesh). Deux modes de jeu \"King of the Hill\" ont été créés : IA contre IA et Joueur contre IA.",
    "tankAIUnity_p1": "Dans ce projet, nous avons utilisé le projet Tanks! d'Unity que nous avons adapté pour introduire les features demandés comme pouvoir hot-swap le moyen de déplacement des tank depuis l'éditeur (A*, Dijkstra et le NavMesh). Deux modes de jeu ont été développé pour ce projet un IA contre IA et Joueur contre IA. De plus, trois comportements d'IA ont été élaborés : l'alpha, axé principalement sur le score, le bêta, qui patrouille ou marque si la zone n'est pas déjà capturée, et l'oméga, qui patrouille ou défend l'alpha en cas d'attaque.<br> La victoire se fait au nombre de points. Une équipe doit atteindre un certain nombre de points pour gagner ou on regarde quelle équipe a le plus de points au bout d’un certain temps. Pour gagner des points, la zone centrale doit être contrôlée, comme dans un \"King of the Hill\". Pour contrôler la zone, il faut qu’au moins un tank soit physiquement présent dedans durant un certain temps. Une fois la zone contrôlée par une équipe, elle lui rapporte des points s’il y a des tanks présents dans la zone. Plus il y a de tanks présents, plus il y a de points gagnés.",
    "tankAIUnity_p2": "J'ai élaboré les algorithmes de déplacement des tanks, incluant A* et Dijkstra, et implémenté la solution interne de déplacement de Unity, à savoir le NavMesh. J'ai également instauré un mécanisme de hot-swap pour le choix du mode de déplacement des tanks, mis en place une technique d'évitement d'obstacles basée sur des raycasts, permettant aux joueurs de piloter un tank, et élaboré un système de scoring associé à la base centrale.",
    "tankAIUnity_p3": "La state machine a été utilisé pour la zone de capture, tandis que le behaviour tree a été utilisé pour modéliser les divers comportements des IA. Ces deux systèmes sont gérés à l'aide de scriptables objects. Les IA interagissent entre elles, partageant des informations telles que la connaissance des ennemis poursuivant l'alpha de l'équipe et des ennemis présents sur la zone de capture.",
    "tankAIUnity_figcaption_1": "IA vs IA",
    "tankAIUnity_figcaption_2": "IA vs IA vs Joueur",
    "tankAIUnity_figcaption_3": "Code couleur différent pour les IA",
    "snowSicknessUnity_subtitle": "Bataille de boule de neige avec Netcode",
    "snowSicknessUnity_about": "Notre équipe de cinq a développé un jeu multijoueur de bataille de boules de neige. Ce jeu a été développé avec la technologie Netcode for GameObjects.",
    "snowSicknessUnity_p1": "Ce projet consistait à créer un jeu avec Netcode sur le thème de Noël, développé en équipe de cinq personnes. Nous avons opté pour un jeu multijoueur en peer to peer où l'objectif est de participer à une bataille de boules de neige. Chaque joueur dispose de trois points de vie et d'une minimap pour repérer sa position et celle de ses adversaires. Lorsqu'un joueur souhaite charger une boule de neige, il doit rester immobile pendant le chargement. La partie se termine lorsqu'il n'y a plus d'adversaires.",
    "snowSicknessUnity_p2": "J'ai intégré Netcode for GameObjects afin de tirer parti de ses fonctionnalités simplifiant le développement de jeux multijoueurs. Cette solution propose une approche flexible et extensible pour la synchronisation des objets réseau, améliorant la gestion des autorités et des prédictions. L'utilisation de Relay, un service de Netcode for GameObjects, simplifie la connexion entre le client et l'hôte.",
    "snowSicknessUnity_p3": "J'ai mis en place le lobby avec ses composants essentiels, incluant la gestion de la connexion, la déconnexion, l'identification du client, le pseudonyme, le code du lobby et la sélection de skins. J'ai implémenté la synchronisation des événements tels que la mort des joueurs par l'utilisation de ServerRPC et ClientRPC. De même, la synchronisation des données telles que la santé, le code du lobby, ou les joueurs, est mise en œuvre à travers l'utilisation de NetworkVariables et NetworkList. Les composants Unity tels qu'Animator, Transform, Rigidbody, etc., sont coordonnés avec l'autorité du client en exploitant les composants natifs de Netcode for GameObjects.",
    "snowSicknessUnity_figcaption_1": "Le lobby",
    "snowSicknessUnity_figcaption_2": "Le podium de fin",
    "middleBlades_subtitle": "Un idle hypercasual",
    "middleBlades_about": "Lors d'un projet, trois jeux hypercasual sont créés en équipe de cinq, chacun intégrant des publicités ou des achats in-app. Celui-ci un jeu de type idle où les joueurs accumulent automatiquement des ressources pour améliorer leur vitesse d'attaque et leurs dégâts.",
    "middleBlades_p1": "L'objectif de ce projet était de créer trois jeux hypercasual, avec une équipe de cinq personnes se répartissant la production individuelle. Chaque jeu devait intégrer des publicités et/ou des achats in-app.<br> Le jeu que j'ai développé, en collaboration avec une autre personne, est de type idle. Un idle est un genre de jeu où les joueurs progressent en accumulant des ressources automatiquement générées, favorisant une expérience de jeu décontractée et continue même en l'absence d'interaction active. Il est également possible d'accélérer la progression et d'améliorer ses statistiques (vitesse d'attaque, dégâts, temps nécessaire pour vaincre le boss de la zone) en effectuant des clics pour apporter de l'aide ou accélérer le processus. Pour élaborer ce jeu, nous nous sommes inspirés du jeu mobile \"Tap Titans\".",
    "middleBlades_p2": "Ayant déjà une expertise dans l'intégration et l'utilisation des publicités, j'ai pris en charge le design, l'interface du jeu et une partie du gameplay. J'ai conçu l'environnement où évolue le héros, gérant la transition lors de la défaite de l'ennemi. J'ai également mis en place le système d'amélioration du héros, créé un boss pour marquer la fin d'un niveau et le passage au suivant, tout en ajoutant des effets et des particules pour renforcer son attrait visuel. La publicité a été intégrée via le service intégré de Unity.",
    "": ""
}